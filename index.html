<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VIBES.md â€” Skills Graph for Agentic Coding</title>
  <meta name="description"
    content="Augment agentic coding with procedural knowledge. Fast search, instant injection, minimal context bloat.">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=JetBrains+Mono:wght@300;400;500&display=swap"
    rel="stylesheet">
  <link rel="icon" type="image/png" href="favicon.png">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-dark: #000000;
      --pipe-color: rgba(255, 255, 255, 0.12);
      --pipe-glow: rgba(255, 255, 255, 0.25);
      --dot-color: #ffffff;
      --accent: #E0FD8C;
      --accent-glow: rgba(224, 253, 140, 0.5);
      --text-primary: rgba(255, 255, 255, 0.95);
      --text-secondary: rgba(255, 255, 255, 0.5);
      --text-tertiary: rgba(255, 255, 255, 0.3);
      --glass-panel: rgba(255, 255, 255, 0.04);
      --glass-border: rgba(255, 255, 255, 0.08);
    }

    html,
    body {
      height: 100%;
    }

    body {
      font-family: 'JetBrains Mono', 'Space Mono', monospace;
      background: var(--bg-dark);
      color: var(--text-primary);
      overflow-x: hidden;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      /* CRT subtle glow */
      text-shadow: 0 0 1px rgba(255, 255, 255, 0.2);
    }

    /* ==========================================
       SUNRISE EFFECT
       ========================================== */
    .sunrise {
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%) translateY(70%);
      width: 200%;
      height: 500px;
      background: radial-gradient(ellipse 70% 100% at 50% 100%,
          rgba(255, 255, 255, 0.06) 0%,
          rgba(255, 255, 255, 0.03) 40%,
          transparent 80%);
      pointer-events: none;
      z-index: 0;
      animation: sunriseFloat 2.5s cubic-bezier(0.16, 1, 0.3, 1) forwards;
      animation-delay: 1.5s;
      opacity: 0;
    }

    @keyframes sunriseFloat {
      0% {
        opacity: 0;
        transform: translateX(-50%) translateY(100%);
      }

      100% {
        opacity: 1;
        transform: translateX(-50%) translateY(40%);
      }
    }

    /* ==========================================
       CONTAINER
       ========================================== */
    .container {
      position: relative;
      z-index: 1;
      width: 100%;
      max-width: 800px;
      padding: 80px 24px 100px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    /* ==========================================
       HERO â€” Logo + Pipes + IDEs
       ========================================== */
    .hero {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      margin-bottom: 80px;
    }

    .logo-container {
      position: relative;
      z-index: 3;
      opacity: 0;
      animation: fadeIn 0.8s ease-out 0.2s forwards;
    }

    @keyframes fadeIn {
      to {
        opacity: 1;
      }
    }

    .logo {
      height: 48px;
      width: auto;
      image-rendering: pixelated;
      filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.4));
    }

    .tagline {
      margin-top: 12px;
      font-size: 11px;
      font-weight: 400;
      color: var(--text-secondary);
      letter-spacing: 0.12em;
      text-transform: uppercase;
      opacity: 0;
      animation: fadeIn 0.8s ease-out 0.6s forwards;
    }

    /* ==========================================
       PIPE CANVAS
       ========================================== */
    #pipe-canvas {
      position: absolute;
      top: 90px;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      max-width: 800px;
      height: 180px;
      z-index: 0;
    }

    /* ==========================================
       IDE ROW
       ========================================== */
    .ide-row {
      position: relative;
      margin-top: 150px;
      opacity: 0;
      animation: fadeInUp 1s cubic-bezier(0.16, 1, 0.3, 1) 1s forwards;
      z-index: 2;
    }

    @keyframes fadeInUp {
      0% {
        opacity: 0;
        transform: translateY(30px);
      }

      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .ide-row img {
      position: relative;
      z-index: 2;
      height: 100px;
      width: auto;
      filter: drop-shadow(0 2px 3px rgba(0, 0, 0, 1));
    }

    .ide-logos {
      position: relative;
      width: 800px;
      height: 100px;
      margin: 0 auto;
      z-index: 2;
    }

    .ide-logos img {
      position: absolute;
      height: 100px;
      width: auto;
      top: 0;
      transform: translateX(-50%);
      filter: drop-shadow(0 2px 3px rgba(0, 0, 0, 1));
    }

    /* Position each logo to match IDE_POSITIONS: [0.12, 0.37, 0.63, 0.88] */
    .ide-logos img:nth-child(1) {
      left: 12%;
    }

    .ide-logos img:nth-child(2) {
      left: 37%;
    }

    .ide-logos img:nth-child(3) {
      left: 63%;
    }

    .ide-logos img:nth-child(4) {
      left: 88%;
    }

    /* Energy Beam behind IDEs */
    .energy-beam {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 200%;
      height: 160px;
      background: linear-gradient(90deg,
          transparent 0%,
          rgba(255, 255, 255, 0.2) 10%,
          rgba(255, 255, 255, 0.35) 50%,
          rgba(255, 255, 255, 0.2) 90%,
          transparent 100%);
      border-radius: 200px;
      filter: blur(80px);
      z-index: 1;
      opacity: 0;
      animation: beamGrow 4s cubic-bezier(0.25, 0.46, 0.45, 0.94) 1.5s forwards;
    }

    @keyframes beamGrow {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.3, 0.2);
      }

      100% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1, 1);
      }
    }

    /* Beam pulse animation */
    .energy-beam::after {
      content: '';
      position: absolute;
      top: -30%;
      left: -10%;
      right: -10%;
      bottom: -30%;
      background: inherit;
      filter: blur(100px);
      animation: beamPulse 4s ease-in-out 4.5s infinite;
    }

    @keyframes beamPulse {

      0%,
      100% {
        opacity: 0.4;
        transform: scaleY(1) scaleX(1);
      }

      50% {
        opacity: 0.7;
        transform: scaleY(1.3) scaleX(1.05);
      }
    }

    /* ==========================================
       VALUE PROP
       ========================================== */
    .value-prop {
      text-align: center;
      max-width: 700px;
      margin-top: 30px;
      opacity: 0;
      animation: fadeIn 1s ease-out 2s forwards;
    }

    .value-prop h2 {
      font-size: 26px;
      font-weight: 500;
      line-height: 1.4;
      margin-bottom: 16px;
      color: var(--text-primary);
    }

    .typewriter {
      display: inline;
    }

    @keyframes typing {
      from {
        width: 0;
      }

      to {
        width: 100%;
      }
    }

    .value-prop p {
      font-size: 15px;
      font-weight: 300;
      color: var(--text-secondary);
      line-height: 1.9;
      overflow: hidden;
    }

    .typewriter-p {
      display: inline;
      overflow: hidden;
      white-space: normal;
      animation: typing-p 2s steps(120, end) 3.2s forwards;
      width: 0;
    }

    @keyframes typing-p {
      from {
        width: 0;
        opacity: 0;
      }

      0.1% {
        opacity: 1;
      }

      to {
        width: 100%;
        opacity: 1;
      }
    }

    /* ==========================================
       SKILL SHARING DIAGRAM
       ========================================== */
    .skill-sharing {
      margin-top: 120px;
      text-align: center;
      opacity: 0;
      animation: fadeIn 1s ease-out 3s forwards;
    }

    .skill-sharing h3 {
      font-size: 14px;
      font-weight: 400;
      color: var(--text-secondary);
      margin-bottom: 30px;
      letter-spacing: 0.15em;
      text-transform: uppercase;
    }

    .sharing-diagram {
      position: relative;
      width: 100%;
      max-width: 1100px;
      height: 420px;
      margin: 0 auto;
      padding: 0 40px;
      box-sizing: border-box;
    }

    #sharing-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .sharing-explanation {
      max-width: 700px;
      margin: 40px auto 0;
      padding: 0 20px;
    }

    .sharing-explanation p {
      font-size: 15px;
      line-height: 1.7;
      color: var(--text-secondary);
      text-align: center;
    }

    /* ==========================================
       INSTALL COMMAND
       ========================================== */
    .install-section {
      margin: 100px auto 80px;
      text-align: center;
      max-width: 700px;
      padding: 0 20px;
      opacity: 0;
      animation: fadeIn 1s ease-out 3.5s forwards;
    }

    .install-command {
      background: rgba(255, 255, 255, 0.06);
      border: none;
      border-radius: 12px;
      padding: 32px 48px;
      display: inline-flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
    }

    .install-command code {
      font-family: 'JetBrains Mono', monospace;
      font-size: 22px;
      color: var(--text-primary);
      letter-spacing: 0.02em;
    }

    .copy-btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 8px;
      border-radius: 6px;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .copy-btn:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .copy-btn svg {
      width: 20px;
      height: 20px;
      stroke: var(--text-secondary);
      transition: stroke 0.2s;
    }

    .copy-btn:hover svg {
      stroke: var(--text-primary);
    }

    .copy-tooltip {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.95);
      color: #000;
      font-size: 11px;
      font-weight: 500;
      padding: 6px 12px;
      border-radius: 6px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      margin-bottom: 8px;
    }

    .copy-btn.copied .copy-tooltip {
      opacity: 1;
    }

    .install-hint {
      font-size: 13px;
      color: var(--text-secondary);
      opacity: 0.6;
    }

    /* ==========================================
       BENEFITS SECTION
       ========================================== */
    .benefits-section {
      margin: 80px auto 100px;
      max-width: 900px;
      padding: 0 20px;
      opacity: 0;
      animation: fadeIn 1s ease-out 4s forwards;
    }

    .benefits-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 40px;
    }

    .benefit-block {
      text-align: center;
      padding: 24px 16px;
      opacity: 0;
      transform: translateY(20px);
    }

    .benefit-block.visible {
      animation: fadeSlideUp 0.6s ease-out forwards;
    }

    .benefit-block:nth-child(2).visible {
      animation-delay: 0.15s;
    }

    .benefit-block:nth-child(3).visible {
      animation-delay: 0.3s;
    }

    @keyframes fadeSlideUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .benefit-icon {
      margin-bottom: 16px;
      opacity: 0.7;
    }

    .benefit-icon svg {
      width: 28px;
      height: 28px;
      stroke: var(--text-primary);
      stroke-width: 1.5;
      fill: none;
    }

    .benefit-title {
      font-size: 15px;
      font-weight: 500;
      color: var(--text-primary);
      margin-bottom: 8px;
      letter-spacing: 0.02em;
    }

    .benefit-desc {
      font-size: 13px;
      color: var(--text-secondary);
      line-height: 1.6;
      min-height: 60px;
    }

    @media (max-width: 700px) {
      .benefits-grid {
        grid-template-columns: 1fr;
        gap: 32px;
      }
    }

    /* ==========================================
       HEADER CTA (Top Right)
       ========================================== */
    .header-cta {
      position: fixed;
      top: 24px;
      right: 24px;
      z-index: 100;
      opacity: 0;
      animation: fadeIn 0.8s ease-out 0.8s forwards;
    }

    .cta-button {
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      font-weight: 500;
      padding: 10px 20px;
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.05);
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .cta-button:hover {
      background: rgba(255, 255, 255, 0.12);
      border-color: rgba(255, 255, 255, 0.5);
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.15);
    }

    /* ==========================================
       WAITLIST MODAL
       ========================================== */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(10px);
      z-index: 1000;
      display: none;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .modal-overlay.active {
      display: flex;
      opacity: 1;
    }

    .modal {
      background: #0a0a0a;
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 16px;
      padding: 48px;
      max-width: 480px;
      width: 90%;
      position: relative;
    }

    .modal-close {
      position: absolute;
      top: 20px;
      right: 20px;
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 24px;
      cursor: pointer;
      opacity: 0.5;
      transition: opacity 0.2s;
    }

    .modal-close:hover {
      opacity: 1;
    }

    .modal h2 {
      font-size: 20px;
      font-weight: 500;
      color: var(--text-primary);
      margin-bottom: 8px;
      letter-spacing: 0.02em;
    }

    .modal-subtitle {
      font-size: 13px;
      color: var(--text-secondary);
      margin-bottom: 32px;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      font-size: 11px;
      font-weight: 500;
      color: var(--text-secondary);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .form-group input,
    .form-group select,
    .form-group textarea {
      width: 100%;
      padding: 12px 16px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 8px;
      color: var(--text-primary);
      outline: none;
      transition: border-color 0.2s, background 0.2s;
      box-sizing: border-box;
    }

    .form-group input:focus,
    .form-group select:focus,
    .form-group textarea:focus {
      border-color: rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.05);
    }

    .form-group input::placeholder,
    .form-group textarea::placeholder {
      color: var(--text-tertiary);
    }

    .form-group select {
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23666' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 16px center;
      cursor: pointer;
    }

    .form-group select option {
      background: #0a0a0a;
      color: var(--text-primary);
    }

    .form-group textarea {
      resize: vertical;
      min-height: 80px;
    }

    .submit-button {
      width: 100%;
      padding: 14px 24px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      background: rgba(255, 255, 255, 0.9);
      color: #000;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      margin-top: 12px;
    }

    .submit-button:hover {
      background: #fff;
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.2);
    }

    .submit-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .form-success {
      text-align: center;
      padding: 40px 0;
    }

    .form-success h3 {
      font-size: 18px;
      color: var(--text-primary);
      margin-bottom: 12px;
    }

    .form-success p {
      font-size: 14px;
      color: var(--text-secondary);
    }

    /* ==========================================
       FOOTER
       ========================================== */
    .footer {
      margin-top: 80px;
      opacity: 0;
      animation: fadeIn 0.8s ease-out 2s forwards;
    }

    .footer p {
      font-size: 10px;
      color: var(--text-tertiary);
      letter-spacing: 0.15em;
      text-transform: uppercase;
    }

    /* ==========================================
       RESPONSIVE
       ========================================== */
    @media (max-width: 600px) {
      .container {
        padding: 60px 16px 80px;
      }

      .logo {
        height: 36px;
      }

      .ide-row img {
        height: 40px;
      }

      .ide-row {
        margin-top: 180px;
      }

      #pipe-canvas {
        height: 160px;
      }

      .value-prop h2 {
        font-size: 16px;
      }
    }
  </style>
</head>

<body>
  <div class="header-cta">
    <a href="#" class="cta-button" id="open-waitlist">Join the Waitlist</a>
  </div>

  <!-- Waitlist Modal -->
  <div class="modal-overlay" id="waitlist-modal">
    <div class="modal">
      <button class="modal-close" id="close-modal">&times;</button>

      <div id="waitlist-form-container">
        <h2>Join the Waitlist</h2>
        <p class="modal-subtitle">Be among the first to supercharge your agents with VIBES.md</p>

        <form id="waitlist-form">
          <div class="form-group">
            <label for="name">Name</label>
            <input type="text" id="name" name="name" placeholder="Your name" required>
          </div>

          <div class="form-group">
            <label for="email">Email</label>
            <input type="email" id="email" name="email" placeholder="you@company.com" required>
          </div>

          <div class="form-group">
            <label for="role">Role</label>
            <select id="role" name="role" required>
              <option value="">Select your role</option>
              <option value="developer">Developer</option>
              <option value="lead">Tech Lead / Engineering Manager</option>
              <option value="founder">Founder / CTO</option>
              <option value="researcher">AI/ML Researcher</option>
              <option value="other">Other</option>
            </select>
          </div>

          <div class="form-group">
            <label for="company">Company (Optional)</label>
            <input type="text" id="company" name="company" placeholder="Your company">
          </div>

          <div class="form-group">
            <label for="usecase">What are you building?</label>
            <textarea id="usecase" name="usecase" placeholder="Tell us about your use case..."></textarea>
          </div>

          <button type="submit" class="submit-button" id="submit-btn">Join Waitlist</button>
        </form>
      </div>

      <div id="form-success" class="form-success" style="display: none;">
        <h3>ðŸŽ‰ You're on the list!</h3>
        <p>We'll be in touch soon with early access.</p>
      </div>
    </div>
  </div>

  <div class="sunrise"></div>

  <div class="container">
    <section class="hero">
      <div class="logo-container">
        <img src="logos/VIBES.md.png" alt="VIBES.md" class="logo">
        <p class="tagline">Skills Graph for Agentic Coding</p>
      </div>

      <canvas id="pipe-canvas"></canvas>

      <div class="ide-row">
        <div class="energy-beam"></div>
        <div class="ide-logos">
          <img src="logos/image 5.png" alt="Claude Code">
          <img src="logos/image 4.png" alt="Cursor">
          <img src="logos/image 1.png" alt="Aurora">
          <img src="logos/image 3.png" alt="Windsurf">
        </div>
      </div>
    </section>

    <section class="value-prop">
      <h2><span class="typewriter">> Supercharge your agent with procedural knowledge_</span></h2>
      <p><span class="typewriter-p">VIBES.md is a skill graph that augments agentic coding with procedural knowledge.
          Evolutionary search finds, ranks, and injects the right skills at inference time â€” without bloating your
          context.</span></p>
    </section>

    <section class="install-section">
      <div class="install-command">
        <code id="install-code">pip install newgraph-client</code>
        <button class="copy-btn" id="copy-btn" title="Copy to clipboard">
          <span class="copy-tooltip">Copied!</span>
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
            stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round"
              d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9.75a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184" />
          </svg>
        </button>
      </div>
      <p class="install-hint">Get started in seconds</p>
    </section>

    <section class="benefits-section">
      <div class="benefits-grid">
        <div class="benefit-block">
          <div class="benefit-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"
              fill="none">
              <path stroke-linecap="round" stroke-linejoin="round"
                d="m3.75 13.5 10.5-11.25L12 10.5h8.25L9.75 21.75 12 13.5H3.75Z" />
            </svg>
          </div>
          <h4 class="benefit-title">Zero Context Bloat</h4>
          <p class="benefit-desc">Skills are injected precisely when needed, not preloaded into every prompt.</p>
        </div>
        <div class="benefit-block">
          <div class="benefit-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"
              fill="none">
              <path stroke-linecap="round" stroke-linejoin="round"
                d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99" />
            </svg>
          </div>
          <h4 class="benefit-title">Evolutionary Ranking</h4>
          <p class="benefit-desc">The best skills rise to the top through continuous community validation.</p>
        </div>
        <div class="benefit-block">
          <div class="benefit-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"
              fill="none">
              <path stroke-linecap="round" stroke-linejoin="round"
                d="M12 21a9.004 9.004 0 0 0 8.716-6.747M12 21a9.004 9.004 0 0 1-8.716-6.747M12 21c2.485 0 4.5-4.03 4.5-9S14.485 3 12 3m0 18c-2.485 0-4.5-4.03-4.5-9S9.515 3 12 3m0 0a8.997 8.997 0 0 1 7.843 4.582M12 3a8.997 8.997 0 0 0-7.843 4.582m15.686 0A11.953 11.953 0 0 1 12 10.5c-2.998 0-5.74-1.1-7.843-2.918m15.686 0A8.959 8.959 0 0 1 21 12c0 .778-.099 1.533-.284 2.253m0 0A17.919 17.919 0 0 1 12 16.5c-3.162 0-6.133-.815-8.716-2.247m0 0A9.015 9.015 0 0 1 3 12c0-1.605.42-3.113 1.157-4.418" />
            </svg>
          </div>
          <h4 class="benefit-title">Shared Memory</h4>
          <p class="benefit-desc">Every agent contributes to a collective intelligence that benefits all developers.</p>
        </div>
      </div>
    </section>

    <section class="skill-sharing">
      <h3>Discover once, benefit everyone</h3>
      <div class="sharing-diagram">
        <canvas id="sharing-canvas"></canvas>
      </div>
      <div class="sharing-explanation">
        <p>Each agent contributes discoveries to a shared epistemic memory. When one developer's agent learns a new
          skill, pattern, or solution, it becomes available to all agents in the network â€” supercharging every developer
          without duplicating effort.</p>
      </div>
    </section>

    <footer class="footer">
      <p>Â© 2026 VIBES.md</p>
    </footer>
  </div>

  <script>
    // ==========================================
    // TERMINAL PIPE ANIMATION
    // Dots flow along fixed paths like unix pipes
    // ==========================================
    const canvas = document.getElementById('pipe-canvas');
    const ctx = canvas.getContext('2d');
    let animationId;
    let dots = [];

    // Retina scaling
    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Path definitions (normalized 0-1 coordinates)
    // Rigid right-angle pipes: down â†’ horizontal â†’ down
    const BRANCH_Y = 0.15;  // Shorter trunk
    const END_Y = 0.85;     // Barely touches top of logos

    // 4 IDE target X positions (aligned to logo centers - 100px logos, 70px gap)
    const IDE_POSITIONS = [0.12, 0.37, 0.63, 0.88];
    const CORNER_RADIUS = 35;

    // A dot that travels along pipe paths with rounded corners
    class PipeDot {
      constructor(targetIndex) {
        this.targetIndex = targetIndex;
        this.progress = 0;
        this.speed = 0.012 + Math.random() * 0.008;
        this.size = 2;
      }

      // Get position along curved pipe path
      getPosition(rect) {
        const centerX = rect.width / 2;
        const targetX = rect.width * IDE_POSITIONS[this.targetIndex];
        const branchY = rect.height * BRANCH_Y;
        const endY = rect.height * END_Y;
        const r = CORNER_RADIUS;
        const dir = targetX > centerX ? 1 : -1;
        const horizontalDist = Math.abs(targetX - centerX);

        // Path segments: straight down | corner1 arc | horizontal | corner2 arc | straight down
        const seg1 = branchY - r;                    // straight down to first corner
        const seg2 = (Math.PI / 2) * r;              // first corner arc (quarter circle)
        const seg3 = horizontalDist - 2 * r;         // horizontal straight
        const seg4 = (Math.PI / 2) * r;              // second corner arc
        const seg5 = endY - branchY - r;             // straight down to end
        const totalPath = seg1 + seg2 + seg3 + seg4 + seg5;

        // Normalized segment boundaries
        const p1 = seg1 / totalPath;
        const p2 = (seg1 + seg2) / totalPath;
        const p3 = (seg1 + seg2 + seg3) / totalPath;
        const p4 = (seg1 + seg2 + seg3 + seg4) / totalPath;

        const p = this.progress;

        if (p < p1) {
          // Segment 1: Straight down
          const t = p / p1;
          return { x: centerX, y: t * (branchY - r) };
        } else if (p < p2) {
          // Segment 2: First corner arc
          const t = (p - p1) / (p2 - p1);
          const angle = Math.PI + (t * Math.PI / 2) * dir;
          const cornerCenterX = centerX + dir * r;
          const cornerCenterY = branchY - r;
          return {
            x: cornerCenterX + Math.cos(angle) * r * -dir,
            y: cornerCenterY + r + Math.sin(angle) * r * -1
          };
        } else if (p < p3) {
          // Segment 3: Horizontal
          const t = (p - p2) / (p3 - p2);
          const startX = centerX + dir * r;
          const endHorizX = targetX - dir * r;
          return { x: startX + t * (endHorizX - startX), y: branchY };
        } else if (p < p4) {
          // Segment 4: Second corner arc
          const t = (p - p3) / (p4 - p3);
          const angle = (dir > 0 ? Math.PI : 0) - (t * Math.PI / 2) * dir;
          const cornerCenterX = targetX - dir * r;
          const cornerCenterY = branchY + r;
          return {
            x: cornerCenterX + Math.cos(angle) * r,
            y: cornerCenterY + Math.sin(angle) * r
          };
        } else {
          // Segment 5: Straight down to end
          const t = (p - p4) / (1 - p4);
          return { x: targetX, y: branchY + r + t * (endY - branchY - r) };
        }
      }

      update() {
        this.progress += this.speed;
        return this.progress < 1;
      }

      draw(rect) {
        const pos = this.getPosition(rect);
        const progressCubed = this.progress * this.progress * this.progress;
        const alpha = 0.6 + (progressCubed * 0.4);
        const size = this.size + (progressCubed * 2);
        const blur = 3 + (progressCubed * 12);

        ctx.save();
        ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
        ctx.shadowBlur = blur;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
        ctx.fill();
        ctx.restore();
      }
    }

    // Draw pipe structure with rounded corners using quadratic curves
    function drawPipes(rect) {
      const centerX = rect.width / 2;
      const branchY = rect.height * BRANCH_Y;
      const endY = rect.height * END_Y;
      const r = 35; // corner radius - more rounded

      ctx.strokeStyle = 'rgba(255, 255, 255, 0.18)';
      ctx.lineWidth = 3;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      // Draw each pipe from center to IDE
      for (let i = 0; i < 4; i++) {
        const targetX = rect.width * IDE_POSITIONS[i];

        ctx.beginPath();
        // Start from top center
        ctx.moveTo(centerX, 0);
        // Down to just before the corner
        ctx.lineTo(centerX, branchY - r);
        // Rounded corner using quadratic curve
        ctx.quadraticCurveTo(centerX, branchY, centerX + (targetX > centerX ? r : -r), branchY);
        // Horizontal to just before the drop
        ctx.lineTo(targetX + (targetX > centerX ? -r : r), branchY);
        // Second rounded corner
        ctx.quadraticCurveTo(targetX, branchY, targetX, branchY + r);
        // Down to the end
        ctx.lineTo(targetX, endY);
        ctx.stroke();
      }

      // Junction dot at center
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.beginPath();
      ctx.arc(centerX, branchY, 4, 0, Math.PI * 2);
      ctx.fill();
    }

    // Spawn dots - waterfall effect
    function spawnDot() {
      if (dots.length < 80) {
        const targetIndex = Math.floor(Math.random() * 4);
        dots.push(new PipeDot(targetIndex));
      }
    }

    // Main animation loop
    function animate() {
      const rect = canvas.getBoundingClientRect();
      ctx.clearRect(0, 0, rect.width, rect.height);

      // Draw static pipes first
      drawPipes(rect);

      // Update and draw dots
      dots = dots.filter(dot => {
        const alive = dot.update();
        if (alive) {
          dot.draw(rect);
        }
        return alive;
      });

      animationId = requestAnimationFrame(animate);
    }

    // Start after delay
    setTimeout(() => {
      animate();
      // Spawn dots very frequently for dense waterfall effect
      setInterval(spawnDot, 35);
    }, 600);

    // Visibility handling
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        cancelAnimationFrame(animationId);
      } else {
        animate();
      }
    });

    // ==========================================
    // SKILL SHARING DIAGRAM - PULLEY SYSTEM
    // ==========================================
    const sharingCanvas = document.getElementById('sharing-canvas');
    const sCtx = sharingCanvas.getContext('2d');
    let sTime = 0;

    // Load IDE logos
    const ideLogos = [
      { src: 'logos/image 5.png', img: new Image() },
      { src: 'logos/image 4.png', img: new Image() },
      { src: 'logos/image 1.png', img: new Image() },
      { src: 'logos/image 3.png', img: new Image() },
    ];
    ideLogos.forEach(logo => logo.img.src = logo.src);

    function resizeSharingCanvas() {
      const rect = sharingCanvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      sharingCanvas.width = rect.width * dpr;
      sharingCanvas.height = rect.height * dpr;
      sCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    resizeSharingCanvas();
    window.addEventListener('resize', resizeSharingCanvas);

    // Layout constants - with padding
    const PADDING = 60;
    const DEV_X = [0.15, 0.38, 0.62, 0.85];
    const IDE_Y = 0.20;
    const DEV_Y = 0.48;
    const LOOP_WIDTH = 80;
    const MEMORY_CY = 0.85;
    const MEMORY_WIDTH = 0.70;
    const MEMORY_HEIGHT = 30;
    const MEMORY_RADIUS = 15;

    // Circle sizes
    const IDE_RADIUS = 35;
    const DEV_RADIUS = 28;

    // Active dots
    let loopDots = [[], [], [], []];
    let memoryDots = [];
    let transferDots = [];

    // Simple dot - no glow, just solid
    class LoopDot {
      constructor(devIndex) {
        this.devIndex = devIndex;
        this.progress = 0;
        this.speed = 0.004 + Math.random() * 0.003;
        this.size = 3;
      }

      getPosition(rect) {
        const w = rect.width;
        const h = rect.height;
        const cx = w * DEV_X[this.devIndex];
        const ideY = h * IDE_Y;
        const devY = h * DEV_Y;
        const halfW = LOOP_WIDTH / 2;

        // Path segments: left-down, DEV-arc, right-up, IDE-arc
        const verticalLen = devY - ideY;
        const arcLen = Math.PI * halfW;  // semicircle
        const total = verticalLen + arcLen + verticalLen + arcLen;

        const s1 = verticalLen / total;
        const s2 = (verticalLen + arcLen) / total;
        const s3 = (verticalLen + arcLen + verticalLen) / total;

        if (this.progress < s1) {
          // Left side going down
          const t = this.progress / s1;
          return { x: cx - halfW, y: ideY + t * verticalLen };
        } else if (this.progress < s2) {
          // Bottom semicircle around DEV (left to right)
          const t = (this.progress - s1) / (s2 - s1);
          const angle = Math.PI - t * Math.PI;  // Ï€ to 0
          return { x: cx + Math.cos(angle) * halfW, y: devY - Math.sin(angle) * halfW };
        } else if (this.progress < s3) {
          // Right side going up
          const t = (this.progress - s2) / (s3 - s2);
          return { x: cx + halfW, y: devY - t * verticalLen };
        } else {
          // Top semicircle around IDE (right to left)
          const t = (this.progress - s3) / (1 - s3);
          const angle = -t * Math.PI;  // 0 to -Ï€
          return { x: cx + Math.cos(angle) * halfW, y: ideY - Math.sin(angle) * halfW };
        }
      }

      update() {
        this.progress += this.speed;
        return this.progress < 1;
      }

      draw(rect) {
        const pos = this.getPosition(rect);
        sCtx.beginPath();
        sCtx.arc(pos.x, pos.y, this.size, 0, Math.PI * 2);
        sCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        sCtx.fill();
      }
    }

    // Memory dot - travels along stadium shape
    class MemoryDot {
      constructor() {
        this.progress = 0;
        this.speed = 0.002 + Math.random() * 0.002;
        this.size = 3;
      }

      getPosition(rect) {
        const w = rect.width;
        const h = rect.height;
        const mcx = w * 0.5;
        const mcy = h * MEMORY_CY;
        const halfW = (w * MEMORY_WIDTH) / 2 - MEMORY_RADIUS;
        const r = MEMORY_RADIUS;

        // Stadium perimeter: left-arc, bottom, right-arc, top
        const arcLen = Math.PI * r;
        const straightLen = halfW * 2;
        const total = arcLen + straightLen + arcLen + straightLen;

        const s1 = arcLen / total;
        const s2 = (arcLen + straightLen) / total;
        const s3 = (arcLen + straightLen + arcLen) / total;

        if (this.progress < s1) {
          // Left semicircle
          const t = this.progress / s1;
          const angle = Math.PI / 2 + t * Math.PI;
          return { x: mcx - halfW + Math.cos(angle) * r, y: mcy + Math.sin(angle) * r };
        } else if (this.progress < s2) {
          // Bottom straight
          const t = (this.progress - s1) / (s2 - s1);
          return { x: mcx - halfW + t * (halfW * 2), y: mcy + r };
        } else if (this.progress < s3) {
          // Right semicircle
          const t = (this.progress - s2) / (s3 - s2);
          const angle = -Math.PI / 2 + t * Math.PI;
          return { x: mcx + halfW + Math.cos(angle) * r, y: mcy + Math.sin(angle) * r };
        } else {
          // Top straight
          const t = (this.progress - s3) / (1 - s3);
          return { x: mcx + halfW - t * (halfW * 2), y: mcy - r };
        }
      }

      update() {
        this.progress += this.speed;
        return this.progress < 1;
      }

      draw(rect) {
        const pos = this.getPosition(rect);
        sCtx.beginPath();
        sCtx.arc(pos.x, pos.y, this.size, 0, Math.PI * 2);
        sCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        sCtx.fill();
      }
    }

    // Transfer dot - between loop and memory
    class TransferDot {
      constructor(devIndex, toMemory) {
        this.devIndex = devIndex;
        this.toMemory = toMemory;
        this.progress = 0;
        this.speed = 0.006 + Math.random() * 0.004;
        this.size = 3;
      }

      getPosition(rect) {
        const w = rect.width;
        const h = rect.height;
        const devX = w * DEV_X[this.devIndex];
        const halfW = LOOP_WIDTH / 2;
        const startY = h * DEV_Y + halfW;  // Bottom of pulley arc
        const endY = h * MEMORY_CY - MEMORY_RADIUS;  // Top of memory

        if (this.toMemory) {
          return { x: devX, y: startY + (endY - startY) * this.progress };
        } else {
          return { x: devX, y: endY + (startY - endY) * this.progress };
        }
      }

      update() {
        this.progress += this.speed;
        return this.progress < 1;
      }

      draw(rect) {
        const pos = this.getPosition(rect);
        sCtx.beginPath();
        sCtx.arc(pos.x, pos.y, this.size, 0, Math.PI * 2);
        sCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        sCtx.fill();
      }
    }

    // Draw pulley loop pipe - wraps around circles
    function drawLoopPipe(rect, devIndex) {
      const w = rect.width;
      const h = rect.height;
      const cx = w * DEV_X[devIndex];
      const ideY = h * IDE_Y;
      const devY = h * DEV_Y;
      const halfW = LOOP_WIDTH / 2;

      sCtx.strokeStyle = 'rgba(255, 255, 255, 0.18)';
      sCtx.lineWidth = 2;
      sCtx.lineCap = 'round';
      sCtx.lineJoin = 'round';

      // Pulley wraps around IDE circle (top) and DEV circle (bottom)
      // Left side: goes down, wraps around DEV bottom, comes up right side, wraps around IDE top
      sCtx.beginPath();

      // Start at left of IDE circle
      sCtx.moveTo(cx - halfW, ideY);

      // Left vertical down to DEV level
      sCtx.lineTo(cx - halfW, devY);

      // Wrap around DEV circle bottom (semicircle from left to right)
      sCtx.arc(cx, devY, halfW, Math.PI, 0, true);

      // Right vertical up to IDE level
      sCtx.lineTo(cx + halfW, ideY);

      // Wrap around IDE circle top (semicircle from right to left)
      sCtx.arc(cx, ideY, halfW, 0, Math.PI, true);

      sCtx.stroke();

      // Vertical pipe from DEV to memory - starts at bottom of DEV embrace
      const devBottom = devY + halfW;
      const memTop = h * MEMORY_CY - MEMORY_RADIUS;
      sCtx.beginPath();
      sCtx.moveTo(cx, devBottom);
      sCtx.lineTo(cx, memTop);
      sCtx.stroke();
    }

    // Draw stadium-shaped memory (rounded rectangle) - pipes connect to top
    function drawMemoryPipe(rect) {
      const w = rect.width;
      const h = rect.height;
      const mcx = w * 0.5;
      const mcy = h * MEMORY_CY;
      const halfW = (w * MEMORY_WIDTH) / 2;
      const r = MEMORY_RADIUS;

      sCtx.strokeStyle = 'rgba(255, 255, 255, 0.18)';
      sCtx.lineWidth = 2;

      // Stadium shape - fully rounded ends
      sCtx.beginPath();
      // Start at top left
      sCtx.moveTo(mcx - halfW + r, mcy - r);
      // Top edge
      sCtx.lineTo(mcx + halfW - r, mcy - r);
      // Right semicircle
      sCtx.arc(mcx + halfW - r, mcy, r, -Math.PI / 2, Math.PI / 2);
      // Bottom edge
      sCtx.lineTo(mcx - halfW + r, mcy + r);
      // Left semicircle
      sCtx.arc(mcx - halfW + r, mcy, r, Math.PI / 2, -Math.PI / 2);
      sCtx.stroke();
    }

    // Draw nodes on top
    function drawNodes(rect) {
      const w = rect.width;
      const h = rect.height;

      DEV_X.forEach((dx, i) => {
        const cx = w * dx;
        const ideY = h * IDE_Y;
        const devY = h * DEV_Y;
        const logoSize = 50;

        // IDE circle
        sCtx.fillStyle = '#000000';
        sCtx.beginPath();
        sCtx.arc(cx, ideY, IDE_RADIUS, 0, Math.PI * 2);
        sCtx.fill();
        sCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        sCtx.lineWidth = 2;
        sCtx.stroke();

        // IDE logo
        const logo = ideLogos[i].img;
        if (logo.complete) {
          sCtx.drawImage(logo, cx - logoSize / 2, ideY - logoSize / 2, logoSize, logoSize);
        }

        // DEV circle
        sCtx.fillStyle = '#000000';
        sCtx.beginPath();
        sCtx.arc(cx, devY, DEV_RADIUS, 0, Math.PI * 2);
        sCtx.fill();
        sCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        sCtx.lineWidth = 2;
        sCtx.stroke();

        // DEV label
        sCtx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        sCtx.font = '10px JetBrains Mono';
        sCtx.textAlign = 'center';
        sCtx.fillText('DEV', cx, devY + 4);
      });

      // Memory label
      sCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
      sCtx.font = '10px JetBrains Mono';
      sCtx.textAlign = 'center';
      sCtx.fillText('SHARED SKILLS', w * 0.5, h * MEMORY_CY + 4);
    }

    function spawnDots() {
      for (let i = 0; i < 4; i++) {
        if (loopDots[i].length < 3 && Math.random() < 0.025) {
          loopDots[i].push(new LoopDot(i));
        }
      }
      if (memoryDots.length < 6 && Math.random() < 0.03) {
        memoryDots.push(new MemoryDot());
      }
      if (transferDots.length < 3 && Math.random() < 0.012) {
        const devIndex = Math.floor(Math.random() * 4);
        const toMemory = Math.random() < 0.6;
        transferDots.push(new TransferDot(devIndex, toMemory));
      }
    }

    function animateSharing() {
      const rect = sharingCanvas.getBoundingClientRect();
      sCtx.clearRect(0, 0, rect.width, rect.height);

      sTime++;
      spawnDots();

      // Layer 1: Pipes
      for (let i = 0; i < 4; i++) {
        drawLoopPipe(rect, i);
      }
      drawMemoryPipe(rect);

      // Layer 2: Dots
      for (let i = 0; i < 4; i++) {
        loopDots[i] = loopDots[i].filter(dot => {
          const alive = dot.update();
          if (alive) dot.draw(rect);
          return alive;
        });
      }
      memoryDots = memoryDots.filter(dot => {
        const alive = dot.update();
        if (alive) dot.draw(rect);
        return alive;
      });
      transferDots = transferDots.filter(dot => {
        const alive = dot.update();
        if (alive) dot.draw(rect);
        return alive;
      });

      // Layer 3: Nodes
      drawNodes(rect);

      requestAnimationFrame(animateSharing);
    }

    setTimeout(() => {
      animateSharing();
    }, 3000);

    // ==========================================
    // WAITLIST MODAL & FORM
    // ==========================================
    const openBtn = document.getElementById('open-waitlist');
    const modal = document.getElementById('waitlist-modal');
    const closeBtn = document.getElementById('close-modal');
    const form = document.getElementById('waitlist-form');
    const formContainer = document.getElementById('waitlist-form-container');
    const formSuccess = document.getElementById('form-success');
    const submitBtn = document.getElementById('submit-btn');

    // Google Apps Script Web App URL
    const GOOGLE_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbyT9utAC4MI2A3P7-kjZQdzQqGNdNp5-7jDH9bbcnzALEAuBibbBsQEfZfx-MSTrSmV/exec';

    openBtn.addEventListener('click', (e) => {
      e.preventDefault();
      modal.classList.add('active');
      document.body.style.overflow = 'hidden';
    });

    closeBtn.addEventListener('click', () => {
      modal.classList.remove('active');
      document.body.style.overflow = '';
    });

    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.classList.remove('active');
        document.body.style.overflow = '';
      }
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && modal.classList.contains('active')) {
        modal.classList.remove('active');
        document.body.style.overflow = '';
      }
    });

    form.addEventListener('submit', async (e) => {
      e.preventDefault();

      submitBtn.disabled = true;
      submitBtn.textContent = 'Submitting...';

      const formData = new FormData(form);
      const data = {
        timestamp: new Date().toISOString(),
        name: formData.get('name'),
        email: formData.get('email'),
        role: formData.get('role'),
        company: formData.get('company') || '',
        usecase: formData.get('usecase') || ''
      };

      try {
        // Submit to Google Sheets via Apps Script
        await fetch(GOOGLE_SCRIPT_URL, {
          method: 'POST',
          mode: 'no-cors',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });

        // Show success (no-cors means we can't check response)
        formContainer.style.display = 'none';
        formSuccess.style.display = 'block';
      } catch (error) {
        console.error('Submission error:', error);
        // Still show success since no-cors doesn't give us error info
        formContainer.style.display = 'none';
        formSuccess.style.display = 'block';
      }
    });

    // ==========================================
    // COPY TO CLIPBOARD
    // ==========================================
    const copyBtn = document.getElementById('copy-btn');
    const installCode = document.getElementById('install-code');

    copyBtn.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(installCode.textContent);
        copyBtn.classList.add('copied');
        setTimeout(() => copyBtn.classList.remove('copied'), 2000);
      } catch (err) {
        console.error('Copy failed:', err);
      }
    });

    // ==========================================
    // SCROLL-TRIGGERED FADE IN FOR BENEFITS
    // ==========================================
    const observerOptions = {
      threshold: 0.2,
      rootMargin: '0px 0px -30px 0px'
    };

    const benefitObserver = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          entry.target.classList.add('visible');
          benefitObserver.unobserve(entry.target);
        }
      });
    }, observerOptions);

    document.querySelectorAll('.benefit-block').forEach(block => {
      benefitObserver.observe(block);
    });
  </script>
</body>

</html>